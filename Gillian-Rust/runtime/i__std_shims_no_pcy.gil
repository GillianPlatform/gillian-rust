proc "std::boxed::Box::<T, A>::leak"(pLft_a, T, A, b) {
     ret := l-nth(l-nth(l-nth(b, 0i), 0i), 0i);
     return
};

proc "<&mut T std::convert::Into<U>>::into"(pLft_a, mutT, U, ref) {
     ret := {{ ref }};
     return
};

proc "std::ptr::NonNull::<T>::as_mut"(pLft_a, pLft_b, T, p) {
        r := [load_value](l-nth(p, 0i), l-nth(p, 1i), {{ "adt", "NonNull", {{ T }} }}, true);
        ret := l-nth(l-nth(r, 0i), 0i);
        return
};

proc "std::option::Option::<T>::as_mut"(pLft_a, T, p) {
         discr := [load_discr](l-nth(p, 0i), l-nth(p, 1i), {{ "adt", "Option", {{ T }} }});
         discr := l-nth(discr, 0i);
         goto [discr = 0i] nn ot;
     nn: ret := {{ 0i, {{ }} }};
         return;
     ot: goto [discr = 1i] sm er;
     sm: ref := {{
               l-nth(p, 0i),
               l+ (
                    l-nth(p, 1i),
                    {{ {{ "vf", 0i, {{ "adt", "Option", {{ T }} }}, 1i }} }}
               )
          }};
          ret := {{ 1i, {{ ref }} }};
         return;
     er: fail[TYPERR]("Invalid discr")
};


proc "core::panicking::panic_explicit"() {
     fail[panic]("core::panicking::panic_explicit")
};

proc "std::rt::begin_panic"(lft, ty, str) {
     fail[panic](str)
};