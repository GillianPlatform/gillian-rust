proc "std::boxed::Box::<T, A>::leak"(pLft_a, T, A, b) {
     ptr := l-nth(l-nth(l-nth(b, 0i), 0i), 0i);
     ret := {{ ptr, {{ null, {{ }} }} }};
     return
};

proc "<&mut T std::convert::Into<U>>::into"(pLft_a, mutT, U, ref) {
     ret := {{ l-nth(ref, 0i) }};
     return
};

proc "std::option::Option::<T>::as_mut"(pLft_a, T, p) {
         ptr := l-nth(p, 0i);
         discr := [load_discr](l-nth(ptr, 0i), l-nth(ptr, 1i), {{ "adt", "Option", {{ T }} }});
         discr := l-nth(discr, 0i);
         goto [discr = 0i] nn ot;
     nn: ret := {{ 0i, {{ }} }};
         return;
     ot: goto [discr = 1i] sm er;
     sm: ref := {{ {{
               l-nth(ptr, 0i),
               l+ (
                    l-nth(ptr, 1i),
                    {{ {{ "vf", 0i, {{ "adt", "Option", {{ T }} }}, 1i }} }}
               )
          }}, null (* we put a null prophecy, but maybe we should actually be more clever than that... *) }};
          ret := {{ 1i, {{ ref }} }};
         return;
     er: fail[TYPERR]("Invalid discr")
};

proc "std::ptr::NonNull::<T>::as_mut"(pLft_a, pLft_b, T, p) {
        p := l-nth(p, 0i);
        r := [load_value](l-nth(p, 0i), l-nth(p, 1i), {{ "adt", "NonNull", {{ T }} }}, true);
        ref := l-nth(l-nth(r, 0i), 0i);
        ret := {{ ref, null }};
        return
};