use std::collections::HashMap;

// use itertools::Itertools;
use pearlite_syn::*;
use proc_macro2::{Span, TokenStream};
use quote::{quote, ToTokens};
use syn::{
    spanned::Spanned, BinOp, Error, ExprPath, Ident, Lit, Member, Pat, PatIdent, PatPath,
    PatStruct, PatTuple, PatTupleStruct, PatWild, Path, QSelf, UnOp,
};

/// A fragment of Pearlite that we support
#[derive(Clone, Debug)]
pub(crate) enum CoreTerm {
    Call(ExprPath, Vec<CoreTerm>),
    MethodCall(Box<CoreTerm>, Ident, Vec<CoreTerm>),
    BinOp(Box<CoreTerm>, BinOp, Box<CoreTerm>),
    UnOp(UnOp, Box<CoreTerm>),
    Final(Box<CoreTerm>),
    Model(Box<CoreTerm>),
    Let(Pat, Box<CoreTerm>, Box<CoreTerm>),
    Match(Box<CoreTerm>, Vec<(Pat, Box<CoreTerm>)>),
    Constructor(ConstructorKind),
    Var(VarKind),
    Lit(Lit),
    Exists(Vec<VarKind>, Box<CoreTerm>),
}

/// Pure-Gilsonite expressions generated by Creusillian. We eliminate all binders since they are replaced by existentials
#[derive(Clone, Debug)]
pub(crate) enum PreGil {
    Call(ExprPath, Vec<PreGil>),
    MethodCall(Box<PreGil>, Ident, Vec<PreGil>),
    BinOp(Box<PreGil>, BinOp, Box<PreGil>),
    UnOp(UnOp, Box<PreGil>),
    Constructor(GilCons),
    Var(VarKind),
    Lit(Lit),
    Final(Box<PreGil>),
    Model(Box<PreGil>),
    Exists(VarKind, Box<PreGil>),
}

impl ToTokens for PreGil {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            PreGil::Call(f, args) => {
                f.to_tokens(tokens);
                tokens.extend(quote! {(#(#args),*)});
            }
            PreGil::MethodCall(m, f, a) => tokens.extend(quote! { (#m).#f (#(#a),*)}),
            PreGil::BinOp(l, o, r) => {
                tokens.extend(quote!( (#l #o #r) ));
            }
            PreGil::UnOp(o, t) => {
                o.to_tokens(tokens);
                t.to_tokens(tokens);
            }
            PreGil::Constructor(ck) => ck.to_tokens(tokens),
            PreGil::Var(v) => v.to_tokens(tokens),
            PreGil::Lit(l) => l.to_tokens(tokens),
            PreGil::Exists(var, body) => tokens.extend(quote! {
                (exists < #var : _ > #body )
            }),
            PreGil::Final(t) => tokens.extend(quote! { (#t).1 }),
            PreGil::Model(_) => todo!("model"),
        }
    }
}

impl PreGil {
    pub(crate) fn conj(self, o: Self) -> Self {
        PreGil::BinOp(Box::new(self), BinOp::And(Default::default()), Box::new(o))
    }
}

#[derive(Clone, Debug)]
pub(crate) enum GilCons {
    Tuple(Vec<PreGil>),
    Struct {
        qself: Option<QSelf>,
        path: Path,
        fields: Vec<(Member, PreGil)>,
    },
    TupleStruct {
        qself: Option<QSelf>,
        path: Path,
        elems: Vec<PreGil>,
    },
}

impl ToTokens for GilCons {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            GilCons::Tuple(ts) => tokens.extend(quote!( (#(#ts),*))),
            GilCons::Struct {
                qself,
                path,
                fields,
            } => {
                let fields = fields.iter().map(|(m, f)| quote! { #m : #f });
                match qself {
                    Some(_) => todo!(),
                    // Some(q) => tokens.extend(quote! { #q :: #path { #(#fields),* }}),
                    None => tokens.extend(quote! { #path { #(#fields),* }}),
                }
            }
            GilCons::TupleStruct { qself, path, elems } => {
                match qself {
                    Some(_) => todo!(),
                    // Some(q) => tokens.extend(quote! { #q :: #path { #(#fields),* }}),
                    None => tokens.extend(quote! { #path ( #(#elems),* )}),
                }
            }
        }
    }
}

#[derive(Clone, Debug)]
pub(crate) enum ConstructorKind {
    Tuple(Vec<CoreTerm>),
    Struct {
        qself: Option<QSelf>,
        path: Path,
        fields: Vec<(Member, CoreTerm)>,
    },
    TupleStruct {
        qself: Option<QSelf>,
        path: Path,
        elems: Vec<CoreTerm>,
    },
}
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub(crate) enum VarKind {
    Source(Ident),
    DeBruijn(u32),
}

#[allow(dead_code)]
pub(crate) fn print_gilsonite(t: CoreTerm) -> syn::Result<TokenStream> {
    match t {
        CoreTerm::Call(_, _) => todo!("call"),
        CoreTerm::MethodCall(_, _, _) => todo!("method"),
        CoreTerm::BinOp(l, o, r) => {
            let l = print_gilsonite(*l)?;
            let r = print_gilsonite(*r)?;

            Ok(quote! { #l #o #r })
        }
        CoreTerm::UnOp(o, t) => {
            let t = print_gilsonite(*t)?;

            Ok(quote! { #o #t })
        }
        CoreTerm::Final(_) => todo!("final"),
        CoreTerm::Model(_) => todo!("model"),
        CoreTerm::Let(_, _, _) => Err(syn::Error::new(Span::call_site(), "unsupported")),
        CoreTerm::Match(_, _) => Err(syn::Error::new(Span::call_site(), "unsupported")),
        CoreTerm::Constructor(c) => match c {
            ConstructorKind::Tuple(t) => {
                let t = t
                    .into_iter()
                    .map(print_gilsonite)
                    .collect::<Result<Vec<_>, _>>()?;
                Ok(quote! {
                    (#(#t),*)
                })
            }
            ConstructorKind::Struct { .. } => {
                // let t = fields
                //     .into_iter()
                //     .map(|(n, f)| {print_gilsonite()})
                //     .collect::<Result<Vec<_>, _>>()?;
                todo!("struct");
                // Ok(quote! {
                //     (#(#t),*)
                // })
            }
            ConstructorKind::TupleStruct { path, elems, .. } => {
                let t = elems
                    .into_iter()
                    .map(print_gilsonite)
                    .collect::<Result<Vec<_>, _>>()?;
                Ok(quote! {
                     #path (#(#t),*)
                })
            }
        },
        CoreTerm::Var(VarKind::Source(i)) => Ok(quote! { #i }),
        CoreTerm::Var(VarKind::DeBruijn(i)) => {
            let i = Ident::new(&format!("a{i}"), Span::call_site());
            Ok(quote! { #i })
        }
        CoreTerm::Exists(ids, t) => {
            let t = print_gilsonite(*t)?;
            Ok(quote! { exists < #(#ids),* > #t})
        }
        CoreTerm::Lit(l) => Ok(quote! { #l }),
    }
}

impl ToTokens for VarKind {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            VarKind::Source(id) => id.to_tokens(tokens),
            VarKind::DeBruijn(i) => {
                Ident::new(&format!("a{i}"), Span::mixed_site()).to_tokens(tokens)
            }
        }
    }
}

pub(crate) fn term_to_core(t: Term) -> syn::Result<CoreTerm> {
    match t {
        Term::Final(TermFinal { term, .. }) => Ok(CoreTerm::Final(Box::new(term_to_core(*term)?))),
        Term::Model(TermModel { term, .. }) => Ok(CoreTerm::Model(Box::new(term_to_core(*term)?))),
        Term::Call(TermCall {
            func,
            paren_token: _,
            args,
        }) => {
            let Term::Path(TermPath { inner }) = *func else {
                return Err(Error::new(func.span(), "Expected path"));
            };
            Ok(CoreTerm::Call(
                inner,
                args.into_iter()
                    .map(term_to_core)
                    .collect::<syn::Result<_>>()?,
            ))
        }
        Term::MethodCall(TermMethodCall {
            receiver,
            method,
            args,
            ..
        }) => Ok(CoreTerm::MethodCall(
            Box::new(term_to_core(*receiver)?),
            method,
            args.into_iter()
                .map(term_to_core)
                .collect::<syn::Result<_>>()?,
        )),
        Term::Binary(TermBinary { left, op, right }) => Ok(CoreTerm::BinOp(
            Box::new(term_to_core(*left)?),
            op,
            Box::new(term_to_core(*right)?),
        )),
        Term::Unary(TermUnary { op, expr }) => {
            Ok(CoreTerm::UnOp(op, Box::new(term_to_core(*expr)?)))
        }
        Term::Block(TermBlock { block, .. }) => block_to_core(block),
        Term::Match(TermMatch { expr, arms, .. }) => {
            let expr = term_to_core(*expr)?;
            let arms = arms
                .into_iter()
                .map(|TermArm { pat, body, .. }| Ok((pat, Box::new(term_to_core(*body)?))))
                .collect::<syn::Result<_>>()?;
            Ok(CoreTerm::Match(Box::new(expr), arms))
        }
        Term::Path(TermPath { inner }) => {
            if inner.qself.is_some() {
                Err(Error::new(inner.span(), "unsupported path"))?;
            };

            let Some(id) = inner.path.get_ident() else {
                Err(Error::new(inner.span(), "unsupported path"))?
            };

            Ok(CoreTerm::Var(VarKind::Source(id.clone())))
        }
        Term::Lit(lit) => Ok(CoreTerm::Lit(lit.lit)),
        _ => Err(Error::new(t.span(), "Unsupported term")),
    }
}

fn block_to_core(b: TBlock) -> syn::Result<CoreTerm> {
    let span = b.span();
    let TBlock { mut stmts, .. } = b;
    let Some(TermStmt::Expr(e)) = stmts.pop() else {
        return Err(Error::new(span, "Block must end with an expression"));
    };

    stmts
        .into_iter()
        .try_rfold(term_to_core(e)?, |acc, stmt| match stmt {
            TermStmt::Local(TLocal {
                pat,
                init: Some(init),
                ..
            }) => Ok(CoreTerm::Let(
                pat,
                Box::new(term_to_core(*init.1)?),
                Box::new(acc),
            )),
            TermStmt::Item(_) => Err(Error::new(stmt.span(), "Unsupported term")),
            TermStmt::Expr(_) => Err(Error::new(stmt.span(), "Unexpected expression in block")),
            TermStmt::Semi(_, _) => Err(Error::new(stmt.span(), "Unexpected expression in block")),
            _ => todo!(),
        })
}

fn remove_bound_vars(p: &Pat, subst: &mut Subst) {
    match p {
        Pat::Ident(PatIdent { ident, .. }) => {
            subst.bindings.remove(&VarKind::Source(ident.clone()));
        }
        Pat::Path(PatPath { .. }) => {
            todo!()
        }
        Pat::Struct(PatStruct { fields, .. }) => {
            fields
                .iter()
                .for_each(|p| remove_bound_vars(&*p.pat, subst));
        }
        Pat::Tuple(PatTuple { elems, .. }) => {
            elems.iter().for_each(|p| remove_bound_vars(p, subst));
        }
        Pat::TupleStruct(PatTupleStruct { elems, .. }) => {
            elems.iter().for_each(|p| remove_bound_vars(p, subst));
        }
        Pat::Wild(PatWild { .. }) => {}
        _ => todo!(),
    }
}

impl CoreTerm {
    pub(crate) fn subst(&mut self, subst: &mut Subst) {
        match self {
            CoreTerm::Call(_, args) => {
                args.iter_mut().for_each(|a| a.subst(subst));
            }
            CoreTerm::MethodCall(receiver, _, args) => {
                receiver.subst(subst);
                args.iter_mut().for_each(|a| a.subst(subst));
            }
            CoreTerm::BinOp(l, _, r) => {
                l.subst(subst);
                r.subst(subst);
            }
            CoreTerm::UnOp(_, t) => {
                t.subst(subst);
            }
            CoreTerm::Final(t) => {
                t.subst(subst);
            }
            CoreTerm::Model(t) => {
                t.subst(subst);
            }
            CoreTerm::Let(_, t, body) => {
                t.subst(subst);
                body.subst(subst);
            }
            CoreTerm::Match(expr, arms) => {
                expr.subst(subst);
                // TODO: Remove bound variables from the substitution.
                arms.iter_mut().for_each(|(pat, body)| {
                    let mut subst = subst.clone();
                    remove_bound_vars(pat, &mut subst);
                    body.subst(&mut subst)
                });
            }
            CoreTerm::Constructor(ConstructorKind::Tuple(elems)) => {
                elems.iter_mut().for_each(|e| e.subst(subst));
            }
            CoreTerm::Constructor(ConstructorKind::Struct { fields, .. }) => {
                fields.iter_mut().for_each(|(_, e)| e.subst(subst));
            }
            CoreTerm::Constructor(ConstructorKind::TupleStruct { elems, .. }) => {
                elems.iter_mut().for_each(|e| e.subst(subst));
            }
            CoreTerm::Var(v) => {
                if let Some(new) = subst.bindings.get(v) {
                    *self = CoreTerm::Var(new.clone());
                }
            }
            CoreTerm::Exists(bnds, t) => {
                let mut subst = subst.clone();
                for b in bnds {
                    subst.bindings.remove(b);
                }
                t.subst(&mut subst)
            }
            CoreTerm::Lit(_) => {}
        }
    }

    fn exists(v: Vec<VarKind>, t: Self) -> Self {
        if v.is_empty() {
            t
        } else {
            Self::Exists(v, Box::new(t))
        }
    }
}

fn build_pat(pat: &Pat, next_free: &mut u32, bound_vars: &mut Vec<VarKind>) -> CoreTerm {
    match pat {
        Pat::Ident(PatIdent { ident, .. }) => {
            if !ident.to_string().chars().nth(0).unwrap().is_uppercase() {
                bound_vars.push(VarKind::Source(ident.clone()));
            }

            CoreTerm::Var(VarKind::Source(ident.clone()))
        }
        Pat::Path(PatPath { .. }) => {
            todo!("build_pat: path")
        }
        Pat::Struct(PatStruct {
            qself,
            path,
            fields,
            ..
        }) => {
            let fields = fields
                .iter()
                .map(|e| (e.member.clone(), build_pat(&*e.pat, next_free, bound_vars)))
                .collect();

            CoreTerm::Constructor(ConstructorKind::Struct {
                fields,
                qself: qself.clone(),
                path: path.clone(),
            })
        }
        Pat::Tuple(PatTuple { elems, .. }) => {
            let elems = elems
                .into_iter()
                .map(|e| build_pat(e, next_free, bound_vars))
                .collect();

            CoreTerm::Constructor(ConstructorKind::Tuple(elems))
        }
        Pat::TupleStruct(PatTupleStruct {
            qself, path, elems, ..
        }) => {
            let elems = elems
                .into_iter()
                .map(|e| build_pat(e, next_free, bound_vars))
                .collect();

            CoreTerm::Constructor(ConstructorKind::TupleStruct {
                elems,
                qself: qself.clone(),
                path: path.clone(),
            })
        }
        Pat::Wild(PatWild { .. }) => {
            let var = VarKind::DeBruijn(*next_free);
            *next_free += 1;
            CoreTerm::Var(var)
        }
        _ => todo!(),
    }
}

// (A \/ B) /\ C => A /\ C \/ B /\ C
// fn flatten_disjunction(t: &mut CoreTerm) -> CoreTerm {
//     match t {
//         CoreTerm::Call(_, _) => todo!(),
//         CoreTerm::MethodCall(_, _, _) => todo!(),
//         CoreTerm::BinOp(_, _, _) => todo!(),
//         CoreTerm::UnOp(_, _) => todo!(),
//         CoreTerm::Final(_) => todo!(),
//         CoreTerm::Model(_) => todo!(),
//         CoreTerm::Let(_, _, _) => todo!(),
//         CoreTerm::Match(_, _) => unreachable!(),
//         CoreTerm::Constructor(_) => todo!(),
//         CoreTerm::Var(_) => (),
//         CoreTerm::Lit(_) => (),
//         CoreTerm::Exists(_, _) => todo!(),
//     }
// }

pub(crate) struct Disjuncts {
    pub(crate) clauses: Vec<(Vec<VarKind>, PreGil)>,
}

pub(crate) fn core_to_sl(t: CoreTerm) -> Disjuncts {
    let mut clauses = Vec::new();

    let mut to_see = vec![t];
    while let Some(t) = to_see.pop() {
        match t {
            // CoreTerm::BinOp(l, BinOp::Or(_), r) => {
            //     to_see.push(*l);
            //     to_see.push(*r);
            // }
            _ => clauses.push((vec![], core_conjunct_to_sl(t))),
        }
    }

    Disjuncts { clauses }
}

/// Translates a pure conjunct to SL .
fn core_conjunct_to_sl(t: CoreTerm) -> PreGil {
    match t {
        CoreTerm::Call(f, args) => {
            PreGil::Call(f, args.into_iter().map(core_conjunct_to_sl).collect())
        }
        CoreTerm::MethodCall(f, n, args) => PreGil::MethodCall(
            Box::new(core_conjunct_to_sl(*f)),
            n,
            args.into_iter().map(core_conjunct_to_sl).collect(),
        ),
        CoreTerm::BinOp(l, o, r) => PreGil::BinOp(
            Box::new(core_conjunct_to_sl(*l)),
            o,
            Box::new(core_conjunct_to_sl(*r)),
        ),
        CoreTerm::UnOp(op, t) => PreGil::UnOp(op, Box::new(core_conjunct_to_sl(*t))),
        CoreTerm::Final(term) => {
            let t = core_conjunct_to_sl(*term);
            PreGil::Final(Box::new(t))
        }
        CoreTerm::Model(_) => todo!("model"),
        CoreTerm::Let(_, _, _) => unreachable!("let bindings should have been eliminated"),
        CoreTerm::Match(_, _) => unreachable!("match expressions should have been eliminated"),
        CoreTerm::Constructor(c) => match c {
            ConstructorKind::Tuple(ts) => PreGil::Constructor(GilCons::Tuple(
                ts.into_iter().map(core_conjunct_to_sl).collect(),
            )),
            ConstructorKind::Struct {
                qself,
                path,
                fields,
            } => PreGil::Constructor(GilCons::Struct {
                qself,
                path,
                fields: fields
                    .into_iter()
                    .map(|f| (f.0, core_conjunct_to_sl(f.1)))
                    .collect(),
            }),
            ConstructorKind::TupleStruct { qself, path, elems } => {
                PreGil::Constructor(GilCons::TupleStruct {
                    qself,
                    path,
                    elems: elems.into_iter().map(core_conjunct_to_sl).collect(),
                })
            }
        },
        CoreTerm::Var(v) => PreGil::Var(v),
        CoreTerm::Lit(l) => PreGil::Lit(l),
        CoreTerm::Exists(v, b) => v.into_iter().fold(core_conjunct_to_sl(*b), |acc, v| {
            PreGil::Exists(v, Box::new(acc))
        }),
    }
}

#[derive(Default, Clone)]
pub(crate) struct Subst {
    pub(crate) bindings: HashMap<VarKind, VarKind>,
}

pub(crate) fn elim_match_form(t: &mut CoreTerm) {
    match t {
        CoreTerm::Call(_, args) => args.iter_mut().for_each(elim_match_form),
        CoreTerm::MethodCall(f, _, args) => {
            elim_match_form(f);
            args.iter_mut().for_each(elim_match_form);
        }
        CoreTerm::BinOp(l, _, r) => {
            elim_match_form(l);
            elim_match_form(r);
        }
        CoreTerm::UnOp(_, t) => elim_match_form(t),
        CoreTerm::Final(t) => elim_match_form(t),
        CoreTerm::Model(t) => elim_match_form(t),
        CoreTerm::Let(p, e, x) => {
            elim_match_form(e);
            elim_match_form(x);
            let mut fvs = Vec::new();
            let patcons = build_pat(p, &mut 0, &mut fvs);
            let eq = Box::new(CoreTerm::BinOp(
                e.clone(),
                BinOp::Eq(Default::default()),
                Box::new(patcons),
            ));

            *t = CoreTerm::exists(
                fvs,
                CoreTerm::BinOp(eq, BinOp::And(Default::default()), x.clone()),
            );
        }
        CoreTerm::Match(x, arms) => {
            elim_match_form(x);

            let mut elim = Vec::new();

            for (pat, body) in arms {
                let mut fvs = Vec::new();
                let patcons = build_pat(pat, &mut 0, &mut fvs);
                elim_match_form(body);
                let eq = Box::new(CoreTerm::BinOp(
                    x.clone(),
                    BinOp::Eq(Default::default()),
                    Box::new(patcons),
                ));

                elim.push(CoreTerm::exists(
                    fvs,
                    CoreTerm::BinOp(eq, BinOp::And(Default::default()), body.clone()),
                ));
            }

            *t = elim
                .into_iter()
                .reduce(|arm, acc| {
                    CoreTerm::BinOp(Box::new(arm), BinOp::Or(Default::default()), Box::new(acc))
                })
                .unwrap();
        }
        CoreTerm::Constructor(c) => match c {
            ConstructorKind::Tuple(ts) => ts.iter_mut().for_each(elim_match_form),
            ConstructorKind::Struct { fields, .. } => fields
                .iter_mut()
                .map(|a| &mut a.1)
                .for_each(elim_match_form),
            ConstructorKind::TupleStruct { elems, .. } => {
                elems.iter_mut().for_each(elim_match_form)
            }
        },
        CoreTerm::Exists(_, e) => elim_match_form(e),
        CoreTerm::Var(_) => (),
        CoreTerm::Lit(_) => (),
    }
}
