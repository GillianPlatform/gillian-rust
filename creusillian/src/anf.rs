use std::collections::HashMap;

use itertools::Itertools;
use pearlite_syn::*;
use proc_macro2::{Span, TokenStream};
use quote::{quote, ToTokens};
use syn::{
    spanned::Spanned, BinOp, Error, ExprPath, Ident, Lit, Member, Pat, PatIdent, PatPath,
    PatStruct, PatTuple, PatTupleStruct, PatWild, Path, QSelf, Token, UnOp, WhereClause,
};

/// A fragment of Pearlite that we support
#[derive(Clone, Debug)]
pub enum CoreTerm {
    Call(ExprPath, Vec<CoreTerm>),
    MethodCall(Box<CoreTerm>, Ident, Vec<CoreTerm>),
    BinOp(Box<CoreTerm>, BinOp, Box<CoreTerm>),
    UnOp(UnOp, Box<CoreTerm>),
    Final(Box<CoreTerm>),
    Model(Box<CoreTerm>),
    Let(Pat, Box<CoreTerm>, Box<CoreTerm>),
    Match(Box<CoreTerm>, Vec<(Pat, Box<CoreTerm>)>),
    Constructor(ConstructorKind),
    Var(VarKind),
    Lit(Lit),
    Exists(Vec<VarKind>, Box<CoreTerm>),
}

/// Pure-Gilsonite expressions generated by Creusillian. We eliminate all binders since they are replaced by existentials
#[derive(Clone, Debug)]
pub enum PreGil {
    Call(ExprPath, Vec<PreGil>),
    MethodCall(Box<PreGil>, Ident, Vec<PreGil>),
    BinOp(Box<PreGil>, BinOp, Box<PreGil>),
    UnOp(UnOp, Box<PreGil>),
    Constructor(GilCons),
    Var(VarKind),
    Lit(Lit),
}

impl ToTokens for PreGil {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            PreGil::Call(f, args) => {
                f.to_tokens(tokens);
                tokens.extend(quote! {(#(#args),*)});
            }
            PreGil::MethodCall(m, f, a) => tokens.extend(quote! { (#m).#f (#(#a),*)}),
            PreGil::BinOp(l, o, r) => {
                tokens.extend(quote!( (#l #o #r) ));
            }
            PreGil::UnOp(o, t) => {
                o.to_tokens(tokens);
                t.to_tokens(tokens);
            }
            PreGil::Constructor(ck) => ck.to_tokens(tokens),
            PreGil::Var(v) => v.to_tokens(tokens),
            PreGil::Lit(l) => l.to_tokens(tokens),
        }
    }
}

impl PreGil {
    pub fn conj(self, o: Self) -> Self {
        PreGil::BinOp(Box::new(self), BinOp::And(Default::default()), Box::new(o))
    }
}

#[derive(Clone, Debug)]
pub enum GilCons {
    Tuple(Vec<PreGil>),
    Struct {
        qself: Option<QSelf>,
        path: Path,
        fields: Vec<(Member, PreGil)>,
    },
    TupleStruct {
        qself: Option<QSelf>,
        path: Path,
        elems: Vec<PreGil>,
    },
}

impl ToTokens for GilCons {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            GilCons::Tuple(ts) => tokens.extend(quote!( (#(#ts),*))),
            GilCons::Struct {
                qself,
                path,
                fields,
            } => {
                let fields = fields.iter().map(|(m, f)| quote! { #m : #f });
                match qself {
                    Some(_) => todo!(),
                    // Some(q) => tokens.extend(quote! { #q :: #path { #(#fields),* }}),
                    None => tokens.extend(quote! { #path { #(#fields),* }}),
                }
            }
            GilCons::TupleStruct { qself, path, elems } => {
                match qself {
                    Some(_) => todo!(),
                    // Some(q) => tokens.extend(quote! { #q :: #path { #(#fields),* }}),
                    None => tokens.extend(quote! { #path ( #(#elems),* )}),
                }
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum ConstructorKind {
    Tuple(Vec<CoreTerm>),
    Struct {
        qself: Option<QSelf>,
        path: Path,
        fields: Vec<(Member, CoreTerm)>,
    },
    TupleStruct {
        qself: Option<QSelf>,
        path: Path,
        elems: Vec<CoreTerm>,
    },
}
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum VarKind {
    Source(Ident),
    DeBruijn(u32),
}

pub fn print_gilsonite(t: CoreTerm) -> syn::Result<TokenStream> {
    match t {
        CoreTerm::Call(_, _) => todo!("call"),
        CoreTerm::MethodCall(_, _, _) => todo!("method"),
        CoreTerm::BinOp(l, o, r) => {
            let l = print_gilsonite(*l)?;
            let r = print_gilsonite(*r)?;

            Ok(quote! { #l #o #r })
        }
        CoreTerm::UnOp(o, t) => {
            let t = print_gilsonite(*t)?;

            Ok(quote! { #o #t })
        }
        CoreTerm::Final(_) => todo!("final"),
        CoreTerm::Model(_) => todo!("model"),
        CoreTerm::Let(_, _, _) => Err(syn::Error::new(Span::call_site(), "unsupported")),
        CoreTerm::Match(_, _) => Err(syn::Error::new(Span::call_site(), "unsupported")),
        CoreTerm::Constructor(c) => match c {
            ConstructorKind::Tuple(t) => {
                let t = t
                    .into_iter()
                    .map(print_gilsonite)
                    .collect::<Result<Vec<_>, _>>()?;
                Ok(quote! {
                    (#(#t),*)
                })
            }
            ConstructorKind::Struct {
                qself,
                path,
                fields,
            } => {
                // let t = fields
                //     .into_iter()
                //     .map(|(n, f)| {print_gilsonite()})
                //     .collect::<Result<Vec<_>, _>>()?;
                todo!("struct");
                // Ok(quote! {
                //     (#(#t),*)
                // })
            }
            ConstructorKind::TupleStruct { qself, path, elems } => {
                let t = elems
                    .into_iter()
                    .map(print_gilsonite)
                    .collect::<Result<Vec<_>, _>>()?;
                Ok(quote! {
                     #path (#(#t),*)
                })
            }
        },
        CoreTerm::Var(VarKind::Source(i)) => Ok(quote! { #i }),
        CoreTerm::Var(VarKind::DeBruijn(i)) => {
            let i = Ident::new(&format!("a{i}"), Span::call_site());
            Ok(quote! { #i })
        }
        CoreTerm::Exists(ids, t) => {
            let t = print_gilsonite(*t)?;
            Ok(quote! { exists < #(#ids),* > #t})
        }
        CoreTerm::Lit(l) => Ok(quote! { #l }),
    }
}

impl ToTokens for VarKind {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            VarKind::Source(id) => id.to_tokens(tokens),
            VarKind::DeBruijn(i) => {
                Ident::new(&format!("a{i}"), Span::mixed_site()).to_tokens(tokens)
            }
        }
    }
}

pub fn term_to_core(t: Term) -> syn::Result<CoreTerm> {
    match t {
        Term::Final(TermFinal { term, .. }) => Ok(CoreTerm::Final(Box::new(term_to_core(*term)?))),
        Term::Model(TermModel { term, .. }) => Ok(CoreTerm::Model(Box::new(term_to_core(*term)?))),
        Term::Call(TermCall {
            func,
            paren_token: _,
            args,
        }) => {
            let Term::Path(TermPath { inner }) = *func else {
                return Err(Error::new(func.span(), "Expected path"));
            };
            Ok(CoreTerm::Call(
                inner,
                args.into_iter()
                    .map(term_to_core)
                    .collect::<syn::Result<_>>()?,
            ))
        }
        Term::MethodCall(TermMethodCall {
            receiver,
            method,
            args,
            ..
        }) => Ok(CoreTerm::MethodCall(
            Box::new(term_to_core(*receiver)?),
            method,
            args.into_iter()
                .map(term_to_core)
                .collect::<syn::Result<_>>()?,
        )),
        Term::Binary(TermBinary { left, op, right }) => Ok(CoreTerm::BinOp(
            Box::new(term_to_core(*left)?),
            op,
            Box::new(term_to_core(*right)?),
        )),
        Term::Unary(TermUnary { op, expr }) => {
            Ok(CoreTerm::UnOp(op, Box::new(term_to_core(*expr)?)))
        }
        Term::Block(TermBlock { label, block }) => block_to_core(block),
        Term::Match(TermMatch {
            expr,
            arms,
            match_token,
            brace_token,
        }) => {
            let expr = term_to_core(*expr)?;
            let arms = arms
                .into_iter()
                .map(
                    |TermArm {
                         pat,
                         guard,
                         fat_arrow_token,
                         body,
                         comma,
                     }| Ok((pat, Box::new(term_to_core(*body)?))),
                )
                .collect::<syn::Result<_>>()?;
            Ok(CoreTerm::Match(Box::new(expr), arms))
        }
        Term::Path(TermPath { inner }) => {
            if inner.qself.is_some() {
                Err(Error::new(inner.span(), "unsupported path"))?;
            };

            let Some(id) = inner.path.get_ident() else {
                Err(Error::new(inner.span(), "unsupported path"))?
            };

            Ok(CoreTerm::Var(VarKind::Source(id.clone())))
        }
        Term::Lit(lit) => Ok(CoreTerm::Lit(lit.lit)),
        _ => Err(Error::new(t.span(), "Unsupported term")),
    }
}

fn block_to_core(b: TBlock) -> syn::Result<CoreTerm> {
    let span = b.span();
    let TBlock {
        mut stmts,
        brace_token,
    } = b;
    let Some(TermStmt::Expr(e)) = stmts.pop() else {
        return Err(Error::new(span, "Block must end with an expression"));
    };

    stmts
        .into_iter()
        .try_rfold(term_to_core(e)?, |acc, stmt| match stmt {
            TermStmt::Local(TLocal {
                let_token,
                pat,
                init: Some(init),
                semi_token,
            }) => Ok(CoreTerm::Let(
                pat,
                Box::new(term_to_core(*init.1)?),
                Box::new(acc),
            )),
            TermStmt::Item(_) => Err(Error::new(stmt.span(), "Unsupported term")),
            TermStmt::Expr(_) => Err(Error::new(stmt.span(), "Unexpected expression in block")),
            TermStmt::Semi(_, _) => Err(Error::new(stmt.span(), "Unexpected expression in block")),
            _ => todo!(),
        })
}

fn remove_bound_vars(p: &Pat, subst: &mut Subst) {
    match p {
        Pat::Ident(PatIdent { ident, .. }) => {
            subst.bindings.remove(&VarKind::Source(ident.clone()));
        }
        Pat::Path(PatPath { qself, path, .. }) => {
            todo!()
        }
        Pat::Struct(PatStruct {
            qself,
            path,
            fields,
            ..
        }) => {
            fields
                .iter()
                .for_each(|p| remove_bound_vars(&*p.pat, subst));
        }
        Pat::Tuple(PatTuple { elems, .. }) => {
            elems.iter().for_each(|p| remove_bound_vars(p, subst));
        }
        Pat::TupleStruct(PatTupleStruct {
            qself, path, elems, ..
        }) => {
            elems.iter().for_each(|p| remove_bound_vars(p, subst));
        }
        Pat::Wild(PatWild { .. }) => {}
        _ => todo!(),
    }
}

impl CoreTerm {
    fn subst(&mut self, subst: &mut Subst) {
        match self {
            CoreTerm::Call(_, args) => {
                args.iter_mut().for_each(|a| a.subst(subst));
            }
            CoreTerm::MethodCall(receiver, _, args) => {
                receiver.subst(subst);
                args.iter_mut().for_each(|a| a.subst(subst));
            }
            CoreTerm::BinOp(l, _, r) => {
                l.subst(subst);
                r.subst(subst);
            }
            CoreTerm::UnOp(_, t) => {
                t.subst(subst);
            }
            CoreTerm::Final(t) => {
                t.subst(subst);
            }
            CoreTerm::Model(t) => {
                t.subst(subst);
            }
            CoreTerm::Let(_, t, body) => {
                t.subst(subst);
                body.subst(subst);
            }
            CoreTerm::Match(expr, arms) => {
                expr.subst(subst);
                // TODO: Remove bound variables from the substitution.
                arms.iter_mut().for_each(|(pat, body)| {
                    let mut subst = subst.clone();
                    remove_bound_vars(pat, &mut subst);
                    body.subst(&mut subst)
                });
            }
            CoreTerm::Constructor(ConstructorKind::Tuple(elems)) => {
                elems.iter_mut().for_each(|e| e.subst(subst));
            }
            CoreTerm::Constructor(ConstructorKind::Struct { fields, .. }) => {
                fields.iter_mut().for_each(|(_, e)| e.subst(subst));
            }
            CoreTerm::Constructor(ConstructorKind::TupleStruct { elems, .. }) => {
                elems.iter_mut().for_each(|e| e.subst(subst));
            }
            CoreTerm::Var(v) => {
                if let Some(new) = subst.bindings.get(v) {
                    *self = CoreTerm::Var(new.clone());
                }
            }
            CoreTerm::Exists(bnds, t) => {
                let mut subst = subst.clone();
                for b in bnds {
                    subst.bindings.remove(b);
                }
                t.subst(&mut subst)
            }
            CoreTerm::Lit(_) => {}
        }
    }

    fn exists(v: Vec<VarKind>, t: Self) -> Self {
        if v.is_empty() {
            t
        } else {
            Self::Exists(v, Box::new(t))
        }
    }
}

#[derive(Clone, Default)]
struct Context {
    asserts: Vec<CoreTerm>,
    bound_vars: u32,
}

fn build_existential_pattern(
    pat: Pat,
    next_free: &mut u32,
    subst: &mut Vec<(VarKind, VarKind)>,
) -> CoreTerm {
    match pat {
        Pat::Ident(PatIdent { ident, .. }) => {
            let var = VarKind::DeBruijn(*next_free);
            *next_free += 1;
            subst.push((VarKind::Source(ident.clone()), var.clone()));
            CoreTerm::Var(var)
        }
        Pat::Path(PatPath { qself, path, .. }) => {
            todo!()
        }
        Pat::Struct(PatStruct {
            qself,
            path,
            fields,
            ..
        }) => {
            let fields = fields
                .into_iter()
                .map(|e| {
                    (
                        e.member,
                        build_existential_pattern(*e.pat, next_free, subst),
                    )
                })
                .collect();

            CoreTerm::Constructor(ConstructorKind::Struct {
                fields,
                qself,
                path,
            })
        }
        Pat::Tuple(PatTuple { elems, .. }) => {
            let elems = elems
                .into_iter()
                .map(|e| build_existential_pattern(e, next_free, subst))
                .collect();

            CoreTerm::Constructor(ConstructorKind::Tuple(elems))
        }
        Pat::TupleStruct(PatTupleStruct {
            qself, path, elems, ..
        }) => {
            let elems = elems
                .into_iter()
                .map(|e| build_existential_pattern(e, next_free, subst))
                .collect();

            CoreTerm::Constructor(ConstructorKind::TupleStruct { elems, qself, path })
        }
        Pat::Wild(PatWild { .. }) => {
            let var = VarKind::DeBruijn(*next_free);
            *next_free += 1;
            CoreTerm::Var(var)
        }
        _ => todo!(),
    }
}

fn build_pat(pat: &Pat, next_free: &mut u32, bound_vars: &mut Vec<VarKind>) -> CoreTerm {
    match pat {
        Pat::Ident(PatIdent { ident, .. }) => {
            if !ident.to_string().chars().nth(0).unwrap().is_uppercase() {
                bound_vars.push(VarKind::Source(ident.clone()));
            }

            CoreTerm::Var(VarKind::Source(ident.clone()))
        }
        Pat::Path(PatPath { .. }) => {
            todo!("build_pat: path")
        }
        Pat::Struct(PatStruct {
            qself,
            path,
            fields,
            ..
        }) => {
            let fields = fields
                .iter()
                .map(|e| (e.member.clone(), build_pat(&*e.pat, next_free, bound_vars)))
                .collect();

            CoreTerm::Constructor(ConstructorKind::Struct {
                fields,
                qself: qself.clone(),
                path: path.clone(),
            })
        }
        Pat::Tuple(PatTuple { elems, .. }) => {
            let elems = elems
                .into_iter()
                .map(|e| build_pat(e, next_free, bound_vars))
                .collect();

            CoreTerm::Constructor(ConstructorKind::Tuple(elems))
        }
        Pat::TupleStruct(PatTupleStruct {
            qself, path, elems, ..
        }) => {
            let elems = elems
                .into_iter()
                .map(|e| build_pat(e, next_free, bound_vars))
                .collect();

            CoreTerm::Constructor(ConstructorKind::TupleStruct {
                elems,
                qself: qself.clone(),
                path: path.clone(),
            })
        }
        Pat::Wild(PatWild { .. }) => {
            let var = VarKind::DeBruijn(*next_free);
            *next_free += 1;
            CoreTerm::Var(var)
        }
        _ => todo!(),
    }
}

// (A \/ B) /\ C => A /\ C \/ B /\ C
// fn flatten_disjunction(t: &mut CoreTerm) -> CoreTerm {
//     match t {
//         CoreTerm::Call(_, _) => todo!(),
//         CoreTerm::MethodCall(_, _, _) => todo!(),
//         CoreTerm::BinOp(_, _, _) => todo!(),
//         CoreTerm::UnOp(_, _) => todo!(),
//         CoreTerm::Final(_) => todo!(),
//         CoreTerm::Model(_) => todo!(),
//         CoreTerm::Let(_, _, _) => todo!(),
//         CoreTerm::Match(_, _) => unreachable!(),
//         CoreTerm::Constructor(_) => todo!(),
//         CoreTerm::Var(_) => (),
//         CoreTerm::Lit(_) => (),
//         CoreTerm::Exists(_, _) => todo!(),
//     }
// }

pub struct Disjuncts {
    pub clauses: Vec<(Vec<VarKind>, PreGil)>,
}

pub fn core_to_sl(t: CoreTerm) -> Disjuncts {
    let mut clauses = Vec::new();

    let mut to_see = vec![t];
    while let Some(t) = to_see.pop() {
        match t {
            CoreTerm::BinOp(l, BinOp::Or(_), r) => {
                to_see.push(*l);
                to_see.push(*r);
            }
            CoreTerm::Exists(ids, t) => clauses.push((ids, core_conjunct_to_sl(*t))),
            _ => clauses.push((vec![], core_conjunct_to_sl(t))),
        }
    }

    Disjuncts { clauses }
}

/// Translates a pure conjunct to SL .
fn core_conjunct_to_sl(t: CoreTerm) -> PreGil {
    match t {
        CoreTerm::Call(f, args) => {
            PreGil::Call(f, args.into_iter().map(core_conjunct_to_sl).collect())
        }
        CoreTerm::MethodCall(f, n, args) => PreGil::MethodCall(
            Box::new(core_conjunct_to_sl(*f)),
            n,
            args.into_iter().map(core_conjunct_to_sl).collect(),
        ),
        CoreTerm::BinOp(l, o, r) => PreGil::BinOp(
            Box::new(core_conjunct_to_sl(*l)),
            o,
            Box::new(core_conjunct_to_sl(*r)),
        ),
        CoreTerm::UnOp(_, _) => todo!(),
        CoreTerm::Final(_) => unreachable!(),
        CoreTerm::Model(_) => unreachable!(),
        CoreTerm::Let(_, _, _) => unreachable!(),
        CoreTerm::Match(_, _) => unreachable!(),
        CoreTerm::Constructor(c) => match c {
            ConstructorKind::Tuple(ts) => PreGil::Constructor(GilCons::Tuple(
                ts.into_iter().map(core_conjunct_to_sl).collect(),
            )),
            ConstructorKind::Struct {
                qself,
                path,
                fields,
            } => PreGil::Constructor(GilCons::Struct {
                qself,
                path,
                fields: fields
                    .into_iter()
                    .map(|f| (f.0, core_conjunct_to_sl(f.1)))
                    .collect(),
            }),
            ConstructorKind::TupleStruct { qself, path, elems } => {
                PreGil::Constructor(GilCons::TupleStruct {
                    qself,
                    path,
                    elems: elems.into_iter().map(core_conjunct_to_sl).collect(),
                })
            }
        },
        CoreTerm::Var(v) => PreGil::Var(v),
        CoreTerm::Lit(l) => PreGil::Lit(l),
        CoreTerm::Exists(_, _) => unreachable!(),
    }
}

impl Context {
    fn extend(&mut self, mut o: Self) -> Subst {
        let shift = (0..o.bound_vars)
            .map(|i| (VarKind::DeBruijn(i), VarKind::DeBruijn(i + self.bound_vars)));
        let shift_subst = Subst {
            bindings: shift.collect(),
        };
        o.asserts
            .iter_mut()
            .for_each(|t| t.subst(&mut shift_subst.clone()));

        self.asserts.extend(o.asserts);
        shift_subst
    }

    fn merge(mut self, o: Self) -> Self {
        self.asserts.extend(o.asserts);
        self
    }

    fn bind(&mut self, pat: Pat, term: CoreTerm, next_fresh: &mut u32) -> Subst {
        // let old_bound_vars = self.bound_vars;
        let mut subst = Vec::new();
        let pattern = build_existential_pattern(pat, next_fresh, &mut subst);
        let subst = Subst {
            bindings: subst.into_iter().collect(),
        };
        self.asserts.push(CoreTerm::BinOp(
            Box::new(term.clone()),
            BinOp::Eq(Default::default()),
            Box::new(pattern),
        ));
        subst
    }
}

#[derive(Default, Clone)]
struct Subst {
    bindings: HashMap<VarKind, VarKind>,
}

impl Subst {
    fn extend(&mut self, o: Subst) {
        todo!()
    }
}

macro_rules! mdo {
    // return
    (return $r:expr ;) => {
      vec![$r]
    };

    // let-binding
    (let $p:pat = $e:expr ; $($r:tt)*) => {{
      let $p = $e;
      mdo!($($r)*)
    }};

    // bind
    (($($binding:pat),*) <- $x:expr ; $($r:tt)*) => {
      $x.into_iter().flat_map(|($($binding),*)| { mdo!($($r)*) }).collect::<Vec<_>>()
    };

    // pure
    ($a:expr) => {
      $a
    }
  }

pub fn elim_match_form(t: &mut CoreTerm) {
    match t {
        CoreTerm::Call(_, args) => args.iter_mut().for_each(elim_match_form),
        CoreTerm::MethodCall(f, _, args) => {
            elim_match_form(f);
            args.iter_mut().for_each(elim_match_form);
        }
        CoreTerm::BinOp(l, _, r) => {
            elim_match_form(l);
            elim_match_form(r);
        }
        CoreTerm::UnOp(_, t) => elim_match_form(t),
        CoreTerm::Final(t) => elim_match_form(t),
        CoreTerm::Model(t) => elim_match_form(t),
        CoreTerm::Let(p, e, x) => {
            elim_match_form(e);
            elim_match_form(x);
            let mut fvs = Vec::new();
            let patcons = build_pat(p, &mut 0, &mut fvs);
            let eq = Box::new(CoreTerm::BinOp(
                e.clone(),
                BinOp::Eq(Default::default()),
                Box::new(patcons),
            ));

            *t = CoreTerm::exists(
                fvs,
                CoreTerm::BinOp(eq, BinOp::And(Default::default()), x.clone()),
            );
        }
        CoreTerm::Match(x, arms) => {
            elim_match_form(x);

            let mut elim = Vec::new();

            for (pat, body) in arms {
                let mut fvs = Vec::new();
                let patcons = build_pat(pat, &mut 0, &mut fvs);
                elim_match_form(body);
                let eq = Box::new(CoreTerm::BinOp(
                    x.clone(),
                    BinOp::Eq(Default::default()),
                    Box::new(patcons),
                ));

                elim.push(CoreTerm::exists(
                    fvs,
                    CoreTerm::BinOp(eq, BinOp::And(Default::default()), body.clone()),
                ));
            }

            *t = elim
                .into_iter()
                .reduce(|arm, acc| {
                    CoreTerm::BinOp(Box::new(arm), BinOp::Or(Default::default()), Box::new(acc))
                })
                .unwrap();
        }
        CoreTerm::Constructor(c) => match c {
            ConstructorKind::Tuple(ts) => ts.iter_mut().for_each(elim_match_form),
            ConstructorKind::Struct { fields, .. } => fields
                .iter_mut()
                .map(|a| &mut a.1)
                .for_each(elim_match_form),
            ConstructorKind::TupleStruct { elems, .. } => {
                elems.iter_mut().for_each(elim_match_form)
            }
        },
        CoreTerm::Exists(_, e) => elim_match_form(e),
        CoreTerm::Var(_) => (),
        CoreTerm::Lit(_) => (),
    }
}

/// Eliminates matches by replacing them with existential quantifications.
/// The result is a pair of a one-hole context and the term which plugs it.
fn eliminate_match(t: CoreTerm, next_fresh: &mut u32) -> Vec<(Context, CoreTerm)> {
    match t {
        CoreTerm::Call(path, args) => {
            let args: Vec<_> = args
                .into_iter()
                .map(|a| eliminate_match(a, next_fresh))
                .collect();
            args.into_iter()
                .multi_cartesian_product()
                .map(|args| {
                    let (ctxs, args): (Vec<_>, _) = args.into_iter().unzip();
                    let (ctx, mut subst) = ctxs.into_iter().fold(
                        (Context::default(), Subst::default()),
                        |(mut ctx, mut subst), new| {
                            let s = ctx.extend(new);
                            subst.extend(s);
                            (ctx, subst)
                        },
                    );
                    let mut t = CoreTerm::Call(path.clone(), args);
                    t.subst(&mut subst);
                    (ctx, t)
                })
                .collect()
        }
        CoreTerm::BinOp(l, op, r) => mdo! {
            (ctx_l, l) <- eliminate_match(*l, next_fresh) ;
            (ctx_r, r) <- eliminate_match(*r.clone(), next_fresh) ;
            return (ctx_l.clone().merge(ctx_r), CoreTerm::BinOp(Box::new(l.clone()), op, Box::new(r))) ;
        },
        CoreTerm::UnOp(op, t) => mdo! {
            (ctx, t) <- eliminate_match(*t, next_fresh) ;
            return (ctx, CoreTerm::UnOp(op, Box::new(t))) ;
        },
        CoreTerm::Final(t) => mdo! {
            (ctx, t) <- eliminate_match(*t, next_fresh) ;
            return (ctx, CoreTerm::Final(Box::new(t))) ;
        },
        CoreTerm::Model(t) => mdo! {
            (ctx, t) <- eliminate_match(*t, next_fresh) ;
            return (ctx, CoreTerm::Model(Box::new(t))) ;
        },
        CoreTerm::Let(pat, t, body) => mdo! {
            (ctx_t, t) <- eliminate_match(*t, next_fresh) ;
            (ctx_body, body) <- eliminate_match((*body).clone(), next_fresh) ;
            return (ctx_t.clone().merge(ctx_body), CoreTerm::Let(pat.clone(), Box::new(t.clone()), Box::new(body))) ;
        },
        CoreTerm::Match(expr, arms) => mdo! {
            (ctx_e, expr) <- eliminate_match(*expr, next_fresh);
            (pat, body) <- arms.clone();

            // let (mut ctx_body, mut body) = todo!();
            (mut ctx_body, mut body) <- eliminate_match(*body, next_fresh);
            let mut subst = ctx_body.extend(ctx_e.clone());
            let () = subst.extend(ctx_body.bind(pat.clone(), expr.clone(), next_fresh));
            let () = body.subst(&mut subst);
            return vec![(ctx_body, body)]

        },
        _ => todo!(),
    }
}
